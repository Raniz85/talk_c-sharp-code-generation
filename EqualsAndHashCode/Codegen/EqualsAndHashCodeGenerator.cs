using System.Collections;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using Microsoft.CodeAnalysis;
using Microsoft.CodeAnalysis.CSharp;
using Microsoft.CodeAnalysis.CSharp.Syntax;
using Microsoft.CodeAnalysis.Text;

namespace Codegen;

[Generator]
public class EqualsAndHashCodeGenerator : IIncrementalGenerator
{
    private const string AttributeSourceCode = @"
// <auto-generated/>

namespace Codegen;

[System.AttributeUsage(System.AttributeTargets.Class)]
public class EqualsAndHashCodeAttribute: System.Attribute
{
}";

    public void Initialize(IncrementalGeneratorInitializationContext context)
    {
        context.RegisterPostInitializationOutput(ctx => ctx.AddSource(
            "EqualsAndHashCodeAttribute",
            SourceText.From(AttributeSourceCode, Encoding.UTF8)));


        var classes = context.SyntaxProvider.ForAttributeWithMetadataName(
                "Codegen.EqualsAndHashCodeAttribute",
                predicate: (_, _) => true,
                transform: (context, _) => context.TargetNode as ClassDeclarationSyntax)
            .Where(static node => node is not null)
            .Collect()
            .Combine(context.CompilationProvider);
        
        context.RegisterSourceOutput(classes,
            static (context, pair) =>
            {
                var (classes, compilation) = pair;
                foreach (var cls in classes)
                {
                    new ImplementationGenerator(cls!, context, compilation).GenerateSourceCode();
                }
            });
    }
}

internal class ImplementationGenerator(ClassDeclarationSyntax cls, SourceProductionContext context, Compilation compilation)
{
    private string ClassName => cls.Identifier.Text;

    private string Namespace =>
        (ModelExtensions.GetDeclaredSymbol(compilation.GetSemanticModel(cls.SyntaxTree), cls) as INamedTypeSymbol)
        .ContainingNamespace
        .ToDisplayString();

    private IEnumerable<string> MemberNames => cls.Members
        .Where(ShouldIncludeMember)
        .SelectMany(GetMemberNames);

    private static bool ShouldIncludeMember(MemberDeclarationSyntax member)
    {
        return member is FieldDeclarationSyntax or PropertyDeclarationSyntax;
    }

    private static IEnumerable<string> GetMemberNames(MemberDeclarationSyntax member)
    {
        return member switch
        {
            PropertyDeclarationSyntax prop => [prop.Identifier.Text],
            FieldDeclarationSyntax field => field.Declaration.Variables.Select(v => v.Identifier.Text),
        };
    }

    public void GenerateSourceCode()
    {
        var sourceCode = $@"
// <auto-generated/>

namespace {Namespace};

public partial class {ClassName}
{{
    public override bool Equals(object? other)
    {{
        return other is {ClassName} o && Equals(o);
    }}

    public bool Equals({ClassName}? other)
    {{
        return other is not null && {string.Join(" && ", MemberNames.Select(name => $"Object.Equals({name}, other.{name})"))};
    }}

    public override int GetHashCode()
    {{
        return HashCode.Combine({string.Join(", ", MemberNames)});
    }}
}}
";
        context.AddSource($"{ClassName}.EqualsAndHashCode", sourceCode);
    }
    
    
    private MethodDeclarationSyntax GenerateEqualsClassMethod(string className, string[] memberNames)
    {
        return SyntaxFactory.MethodDeclaration(
                SyntaxFactory.PredefinedType(SyntaxFactory.Token(SyntaxKind.BoolKeyword)), "Equals")
            .AddModifiers(SyntaxFactory.Token(SyntaxKind.PublicKeyword))
            .AddParameterListParameters(
                SyntaxFactory.Parameter(SyntaxFactory.Identifier("other"))
                    .WithType(SyntaxFactory.NullableType(SyntaxFactory.IdentifierName(className))))
            .WithBody(SyntaxFactory.Block(
                SyntaxFactory.ReturnStatement(
                    SyntaxFactory.BinaryExpression(SyntaxKind.LogicalAndExpression,
                        SyntaxFactory.IdentifierName("other"),
                        MemberNames
                            .Select(name => (ExpressionSyntax) SyntaxFactory.InvocationExpression(SyntaxFactory.IdentifierName("Object.Equals"))
                                .AddArgumentListArguments(
                                    SyntaxFactory.Argument(SyntaxFactory.IdentifierName(name)),
                                    SyntaxFactory.Argument(SyntaxFactory.MemberAccessExpression(SyntaxKind.SimpleMemberAccessExpression,
                                        SyntaxFactory.IdentifierName("other"),
                                        SyntaxFactory.IdentifierName(name)))))
                            .Aggregate((current, next) => SyntaxFactory.BinaryExpression(SyntaxKind.LogicalAndExpression, current, next))
            ))));
    }
}